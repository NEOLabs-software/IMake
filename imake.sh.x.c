#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f imake.sh 
#endif

static  char data [] = 
#define      chk1_z	22
#define      chk1	((&data[1]))
	"\373\361\017\375\340\012\356\366\242\277\141\157\326\370\217\262"
	"\310\317\004\132\314\325\315\362\130\104"
#define      inlo_z	3
#define      inlo	((&data[26]))
	"\016\177\165"
#define      tst1_z	22
#define      tst1	((&data[32]))
	"\235\213\253\217\336\337\277\332\324\100\110\360\023\076\010\372"
	"\172\010\270\335\235\167\321\336\100"
#define      rlax_z	1
#define      rlax	((&data[54]))
	"\334"
#define      date_z	1
#define      date	((&data[55]))
	"\006"
#define      shll_z	10
#define      shll	((&data[58]))
	"\236\157\331\310\212\205\101\123\151\032\334\122\213\362"
#define      xecc_z	15
#define      xecc	((&data[70]))
	"\235\153\345\211\244\113\326\304\175\317\326\107\360\377\257\217"
	"\255"
#define      msg2_z	19
#define      msg2	((&data[89]))
	"\305\322\263\012\154\131\327\163\260\131\275\351\264\060\056\037"
	"\157\144\113\070\355"
#define      lsto_z	1
#define      lsto	((&data[108]))
	"\175"
#define      opts_z	1
#define      opts	((&data[109]))
	"\320"
#define      text_z	1431
#define      text	((&data[405]))
	"\004\202\324\107\164\374\007\141\233\166\354\215\330\015\021\147"
	"\273\222\351\302\127\273\377\167\023\302\240\011\022\163\263\026"
	"\365\207\135\152\204\144\313\037\333\270\255\263\306\277\033\201"
	"\121\004\104\251\300\103\040\323\006\300\334\030\064\220\057\052"
	"\030\214\224\234\361\140\274\315\031\151\201\337\050\234\140\171"
	"\240\245\042\140\350\103\064\356\004\021\007\070\241\067\143\271"
	"\304\367\126\265\130\022\203\161\173\004\120\243\240\261\035\101"
	"\126\077\242\077\203\326\056\207\347\066\300\211\155\043\103\061"
	"\033\231\347\163\253\152\345\046\156\066\311\017\350\346\120\077"
	"\046\362\176\251\311\254\061\260\343\361\072\120\024\175\202\060"
	"\026\151\244\301\323\211\347\101\300\261\120\250\230\241\347\276"
	"\224\146\150\135\023\232\016\366\213\110\106\240\305\311\321\333"
	"\062\165\235\005\377\204\107\277\066\230\150\316\071\117\215\315"
	"\265\366\053\310\220\071\277\034\201\006\275\107\317\216\042\001"
	"\003\300\007\002\105\116\302\173\347\052\111\040\171\327\356\057"
	"\315\032\370\135\123\267\171\324\275\066\033\215\305\076\216\310"
	"\376\225\313\103\344\216\277\313\270\011\354\062\340\333\142\256"
	"\365\132\013\111\022\205\035\320\274\071\135\202\170\354\112\167"
	"\202\026\273\147\244\172\062\116\265\052\262\153\330\070\147\157"
	"\215\166\252\106\263\230\260\322\310\127\276\167\126\143\300\350"
	"\164\212\313\247\227\361\143\037\037\157\216\356\236\371\342\033"
	"\011\036\115\365\070\050\362\221\172\214\175\215\140\237\270\277"
	"\157\004\117\005\041\372\120\131\220\374\270\001\133\074\002\267"
	"\270\113\200\155\221\212\333\105\357\345\212\265\273\374\257\227"
	"\027\161\262\125\156\061\036\007\312\302\166\112\306\216\343\276"
	"\064\377\377\254\220\016\373\303\020\046\144\066\362\126\002\013"
	"\175\107\253\062\026\213\231\363\227\140\323\217\217\345\217\213"
	"\230\160\305\324\024\255\054\070\005\260\371\175\026\125\024\070"
	"\131\013\267\254\174\150\013\152\061\356\264\061\156\005\013\375"
	"\067\073\365\230\336\354\014\055\366\016\107\171\036\341\224\106"
	"\043\102\066\340\250\017\353\006\207\103\164\052\242\233\113\225"
	"\244\142\206\340\106\274\244\234\226\266\003\004\167\047\363\151"
	"\061\203\016\115\320\003\043\311\227\043\077\220\342\221\335\347"
	"\277\026\303\101\222\273\042\237\246\020\314\307\341\267\030\144"
	"\237\231\156\167\121\345\274\026\006\231\231\006\325\057\147\241"
	"\135\177\321\111\046\215\174\270\010\045\343\103\102\260\065\145"
	"\362\372\126\217\334\063\225\166\055\373\311\230\036\122\034\144"
	"\255\276\144\056\115\253\175\344\143\075\131\031\241\074\167\003"
	"\044\347\055\303\221\371\157\347\107\136\244\060\003\336\033\130"
	"\162\267\137\244\100\223\022\231\330\061\124\356\261\175\340\321"
	"\114\317\006\261\105\323\207\074\257\347\330\077\307\072\245\006"
	"\113\171\347\174\070\254\014\112\257\122\054\117\164\010\047\333"
	"\354\372\075\072\315\243\062\000\213\325\025\110\062\301\126\324"
	"\255\036\314\123\275\235\374\271\125\215\255\003\312\311\334\011"
	"\157\016\317\024\317\165\024\340\176\360\067\327\000\126\217\316"
	"\146\306\033\367\141\347\270\366\215\245\064\061\310\300\327\274"
	"\225\105\240\352\326\003\006\262\367\174\065\236\303\077\117\363"
	"\314\036\062\170\165\231\335\073\267\123\333\041\242\065\033\271"
	"\153\115\371\226\343\310\010\102\030\010\204\020\165\370\024\122"
	"\137\006\072\217\207\347\077\313\002\214\244\005\252\216\065\027"
	"\216\224\173\152\374\060\067\151\067\207\234\020\026\131\344\245"
	"\320\016\127\307\026\141\074\355\132\331\071\235\232\025\171\041"
	"\044\156\153\272\072\102\246\126\035\243\367\217\176\110\010\002"
	"\036\313\336\256\243\137\212\322\103\113\215\275\065\242\103\000"
	"\353\335\115\254\312\271\130\103\357\306\216\115\033\314\253\053"
	"\252\320\371\267\342\011\051\012\241\246\335\050\363\124\232\353"
	"\000\331\340\362\177\307\110\270\010\226\115\315\342\320\211\131"
	"\301\242\346\156\225\216\152\117\372\341\144\165\012\045\134\336"
	"\226\371\031\215\270\276\050\174\375\340\110\273\324\244\310\134"
	"\046\216\325\070\174\176\075\164\366\370\074\036\037\057\354\317"
	"\315\351\207\026\215\142\271\250\160\114\214\203\056\270\044\254"
	"\302\210\136\225\365\333\171\145\170\313\042\056\214\126\157\062"
	"\341\367\064\200\146\201\044\272\253\340\325\261\337\126\002\255"
	"\045\363\341\025\222\124\150\252\373\265\364\151\133\110\272\067"
	"\043\216\154\170\344\112\237\203\303\124\273\036\371\301\304\302"
	"\046\147\063\053\153\335\051\056\317\062\256\224\307\324\202\103"
	"\201\006\227\063\300\167\235\353\250\111\351\003\127\317\120\211"
	"\235\106\201\317\176\304\163\007\135\021\300\111\204\131\040\276"
	"\310\344\256\112\166\207\256\011\053\065\047\223\216\162\140\240"
	"\147\222\372\223\204\011\340\215\016\156\371\055\331\313\313\155"
	"\366\344\231\051\362\245\113\016\226\010\374\306\346\015\265\042"
	"\031\312\275\212\303\350\356\071\111\107\332\005\104\117\335\020"
	"\172\226\223\166\130\223\240\302\324\132\351\060\354\362\042\102"
	"\250\200\124\274\276\173\032\060\215\316\371\225\267\340\223\237"
	"\044\321\207\151\026\221\275\117\261\141\206\157\062\036\020\015"
	"\040\005\231\357\377\276\166\336\020\277\312\157\115\302\044\353"
	"\006\111\101\047\311\272\133\227\312\232\302\357\133\137\071\270"
	"\316\213\243\371\022\246\152\003\053\017\144\325\165\253\314\014"
	"\041\257\314\003\053\366\252\071\354\151\031\145\042\105\002\202"
	"\012\332\126\161\316\216\315\337\167\141\013\201\013\232\302\124"
	"\373\153\144\175\351\230\033\337\376\214\347\121\043\113\035\077"
	"\337\141\226\147\002\325\353\004\152\301\302\000\072\052\366\112"
	"\356\311\126\107\133\063\044\160\033\104\167\305\355\257\263\125"
	"\231\174\244\354\211\316\366\162\267\042\350\324\252\217\070\257"
	"\270\230\334\361\105\101\176\244\376\052\363\226\011\252\255\152"
	"\027\075\230\011\155\312\333\363\316\062\324\241\254\125\273\224"
	"\310\363\015\107\206\364\342\114\063\332\054\075\037\221\154\316"
	"\127\102\030\347\370\073\331\120\135\261\173\032\034\016\115\051"
	"\105\252\314\002\063\062\121\352\172\111\210\212\272\017\155\132"
	"\002\262\325\353\343\233\067\142\115\037\124\307\013\163\350\263"
	"\374\070\345\031\107\137\136\204\257\367\357\260\005\100\364\152"
	"\332\327\144\357\153\217\231\125\374\341\164\100\170\013\257\261"
	"\206\016\377\223\246\240\010\232\212\272\040\126\120\157\004\242"
	"\272\271\211\111\366\140\216\056\036\370\350\002\077\003\211\223"
	"\306\337\010\313\322\035\057\321\061\103\317\314\324\231\013\120"
	"\253\023\307\331\110\373\105\120\362\356\231\212\003\100\043\244"
	"\245\004\103\173\002\101\313\224\166\171\322\274\037\142\135\112"
	"\142\140\052\361\154\013\116\233\141\221\116\240\332\262\053\036"
	"\040\364\017\171\351\343\106\340\322\126\366\271\335\102\217\321"
	"\127\356\226\123\254\035\313\362\156\257\032\030\306\245\350\164"
	"\255\353\072\033\077\211\060\362\240\105\241\233\143\377\256\137"
	"\227\143\232\243\264\241\002\104\130\130\133\235\330\241\146\220"
	"\061\317\076\362\107\342\010\367\172\140\160\137\257\201\246\114"
	"\065\321\174\227\277\366\237\013\107\141\167\152\251\160\213\367"
	"\040\120\210\225\173\314\133\132\172\331\222\063\134\177\007\061"
	"\341\005\270\222\005\241\222\063\170\312\222\303\330\164\103\065"
	"\124\141\103\372\070\037\003\164\166\244\117\264\154\276\077\227"
	"\312\367\132\130\325\365\132\262\041\370\213\316\115\274\134\204"
	"\037\217\144\373\361\022\361\114\036\072\136\244\130\057\141\221"
	"\215\343\012\171\056\201\374\105\074\143\351\267\226\106\073\265"
	"\326\240\261\307\263\242\023\322\334\162\167\064\241\330\306\056"
	"\274\320\250\352\122\244\060\217\007\031\107\236\140\203\123\066"
	"\043\005\375\327\247\021\251\204\204\040\271\046\371\177\124\265"
	"\120\375\240\243\241\320\063\251\352\172\107\112\375\233\201\041"
	"\240\177\370\110\220\241\314\024\302\205\073\274\005\217\162\126"
	"\215\022\371\056\343\054\330\315\246\037\030\244\273\231\305\133"
	"\030\275\244\251\137\160\276\042\366\371\336\373\211\120\121\026"
	"\143\113\105\107\167\035\025\036\075\056\303\370\307\210\124\340"
	"\106\370\212\246\151\111\311\137\102\250\132\314\371\254\343\134"
	"\367\050\244\157\106\271\216\204\347\121\175\257\331\321\217\040"
	"\312\032\306\063\143\217\223\246\070\356\162\061\233\126\215\222"
	"\176\061\002\305\353\220\111\322\341\306\201\273\230\021\334\142"
	"\054\242\226\217\062\052\066\152\030\251\233"
#define      tst2_z	19
#define      tst2	((&data[2077]))
	"\106\175\133\110\305\165\371\071\070\222\340\371\163\312\313\030"
	"\105\034\006\070\036\111\015"
#define      chk2_z	19
#define      chk2	((&data[2097]))
	"\214\316\134\065\100\072\316\277\162\074\046\377\114\210\362\116"
	"\247\372\242\116\031\273\122\232"
#define      pswd_z	256
#define      pswd	((&data[2179]))
	"\123\116\330\366\344\150\050\017\236\223\047\107\057\333\106\131"
	"\041\304\264\152\010\373\104\224\024\377\347\257\166\322\133\312"
	"\040\064\300\005\234\350\024\072\174\074\202\254\027\311\005\071"
	"\215\272\243\225\266\347\052\312\347\021\172\335\102\044\272\165"
	"\321\352\060\111\064\243\007\160\065\116\223\263\344\324\070\307"
	"\210\126\234\217\070\367\271\000\156\337\336\261\004\231\047\325"
	"\204\127\037\270\373\047\051\060\165\274\344\131\221\034\040\031"
	"\163\275\251\253\264\143\254\043\102\212\324\106\044\373\034\250"
	"\123\073\141\116\143\212\177\331\107\143\062\330\200\123\362\364"
	"\021\233\237\306\376\113\351\101\326\276\207\372\272\244\243\016"
	"\340\004\134\103\217\334\034\326\100\117\256\300\243\241\264\265"
	"\075\124\173\073\240\145\174\166\044\004\161\337\251\024\355\211"
	"\031\112\315\250\046\351\177\146\071\056\047\335\317\334\222\014"
	"\060\016\110\321\163\305\107\227\311\271\166\163\316\144\374\347"
	"\256\311\220\324\263\017\073\355\075\143\312\015\077\135\031\160"
	"\153\142\101\337\047\211\166\361\102\355\144\021\122\141\370\000"
	"\053\211\325\337\230\020\314\326\164\227\343\263\365\375\044\140"
	"\137\145\077\207\356\266\170\061\244\335\102\366\076\073\367\151"
	"\305\314\110\135\335\025\064\121\255\030\004\242\026\050\003\166"
	"\216\103\375\175\372\166\257\236\123\361\225\136\344\325\050\005"
	"\011\350\012\245\321\037\340\116\133\142\372\162\053\000\253\271"
	"\272\117\117\160\067\171\073\036\213\265\175\160\213\245\165\225"
	"\216\200\073\137\240\033"
#define      msg1_z	65
#define      msg1	((&data[2494]))
	"\250\156\251\250\032\143\143\151\262\324\241\054\020\300\270\305"
	"\014\206\165\166\237\275\317\201\334\062\014\204\252\237\235\247"
	"\054\236\116\307\323\313\250\200\213\224\245\115\241\223\277\021"
	"\302\210\336\043\262\036\252\036\175\321\302\320\217\173\147\147"
	"\272\132\304\203\060\170\217\134\043\225\201\215\367\112\304\315"
	"\323\075\050\121\343\236\346\161\037"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
